NDSummary.OnToolTipsLoaded("CSharpClass:CyclicGraphDepthAnalysis",{848:"<div class=\"NDToolTip TClass LCSharp\"><div class=\"NDClassPrototype\" id=\"NDClassPrototype848\"><div class=\"CPEntry TClass Current\"><div class=\"CPModifiers\"><span class=\"SHKeyword\">public sealed</span></div><div class=\"CPName\">CyclicGraphDepthAnalysis</div></div></div><div class=\"TTSummary\">An algorithm for calculating the depth of each node in an cyclic graph.&nbsp; Input nodes are defined as being at depth 0, and the depth of all other nodes is a determined as per the following scheme:&nbsp; Multiple separate traversals of the graph are made, one starting at each input node. Each traversal assigns a depth value to the visited nodes, and where a node is on multiple paths, the highest depth value is recorded.&nbsp; Once all traversal are complete, the average of all depths recorded against each node is calculated and rounded up to the nearest integer. Finally, if the scheme has resulted in empty layers (e.g. a node allocated to depth 2, but no nodes at depth 1) then the depth values are adjusted to remove the empty layer(s).&nbsp; The motivation for this slightly convoluted scheme is to create \'balanced\' depth allocations when large cyclic loops might assign nodes very high depth values that might not be warranted, e.g. if most connections to a node would assign it a low depth, but a single cycle assigns it a high depth. Use of a mean/average depth is a compromise on the depth allocation of such a node. Median, min, or max could also be used, or indeed any aggregate function.&nbsp; The graph traversal algorithm uses function recursion. A number of other classes in SharpNEAT perform graph traversal by using a separate traversal stack (stored on the heap); that approach is faster but more complex, thus this class has not been converted to the faster approach because it is not directly used in the evolutionary algorithm. At time of writing this class is used only for graph visualization.</div></div>",850:"<div class=\"NDToolTip TVariable LCSharp\"><div id=\"NDPrototype850\" class=\"NDPrototype\"><div class=\"PSection PPlainSection\">DirectedGraph? _digraph</div></div></div>",851:"<div class=\"NDToolTip TVariable LCSharp\"><div id=\"NDPrototype851\" class=\"NDPrototype\"><div class=\"PSection PPlainSection\">BoolArray _ancestorNodeBitmap</div></div></div>",852:"<div class=\"NDToolTip TVariable LCSharp\"><div id=\"NDPrototype852\" class=\"NDPrototype\"><div class=\"PSection PPlainSection\">LightweightList&lt;<span class=\"SHKeyword\">int</span>&gt;[] _nodeDepthMatrix</div></div></div>",853:"<div class=\"NDToolTip TVariable LCSharp\"><div id=\"NDPrototype853\" class=\"NDPrototype\"><div class=\"PSection PPlainSection\"><span class=\"SHKeyword\">int</span> _reentranceFlag</div></div></div>",855:"<div class=\"NDToolTip TFunction LCSharp\"><div id=\"NDPrototype855\" class=\"NDPrototype WideForm\"><div class=\"PSection PParameterSection CStyle\"><table><tr><td class=\"PBeforeParameters\"><span class=\"SHKeyword\">public</span> GraphDepthInfo CalculateNodeDepths(</td><td class=\"PParametersParentCell\"><table class=\"PParameters\"><tr><td class=\"PType first\">DirectedGraph&nbsp;</td><td class=\"PName last\">digraph</td></tr></table></td><td class=\"PAfterParameters\">)</td></tr></table></div></div><div class=\"TTSummary\">Calculate node depths in a cyclic network.</div></div>",856:"<div class=\"NDToolTip TFunction LCSharp\"><div id=\"NDPrototype856\" class=\"NDPrototype WideForm\"><div class=\"PSection PParameterSection CStyle\"><table><tr><td class=\"PBeforeParameters\"><span class=\"SHKeyword\">private void</span> EnsureNodeCapacity(</td><td class=\"PParametersParentCell\"><table class=\"PParameters\"><tr><td class=\"PType first\"><span class=\"SHKeyword\">int</span>&nbsp;</td><td class=\"PName last\">requiredCapacity,</td></tr><tr><td class=\"PType first\"><span class=\"SHKeyword\">int</span>&nbsp;</td><td class=\"PName last\">inputCount</td></tr></table></td><td class=\"PAfterParameters\">)</td></tr></table></div></div></div>",857:"<div class=\"NDToolTip TFunction LCSharp\"><div id=\"NDPrototype857\" class=\"NDPrototype WideForm\"><div class=\"PSection PParameterSection CStyle\"><table><tr><td class=\"PBeforeParameters\"><span class=\"SHKeyword\">private void</span> TraverseNode(</td><td class=\"PParametersParentCell\"><table class=\"PParameters\"><tr><td class=\"PType first\"><span class=\"SHKeyword\">int</span>&nbsp;</td><td class=\"PName last\">nodeIdx,</td></tr><tr><td class=\"PType first\"><span class=\"SHKeyword\">int</span>&nbsp;</td><td class=\"PName last\">depth</td></tr></table></td><td class=\"PAfterParameters\">)</td></tr></table></div></div></div>",858:"<div class=\"NDToolTip TFunction LCSharp\"><div id=\"NDPrototype858\" class=\"NDPrototype\"><div class=\"PSection PPlainSection\"><span class=\"SHKeyword\">private void</span> RecordTraversalNodeDepths()</div></div></div>",859:"<div class=\"NDToolTip TFunction LCSharp\"><div id=\"NDPrototype859\" class=\"NDPrototype\"><div class=\"PSection PPlainSection\"><span class=\"SHKeyword\">private void</span> DetermineFinalNodeDepths()</div></div></div>",860:"<div class=\"NDToolTip TFunction LCSharp\"><div id=\"NDPrototype860\" class=\"NDPrototype\"><div class=\"PSection PPlainSection\"><span class=\"SHKeyword\">private void</span> Cleanup()</div></div></div>",861:"<div class=\"NDToolTip TFunction LCSharp\"><div id=\"NDPrototype861\" class=\"NDPrototype WideForm\"><div class=\"PSection PParameterSection CStyle\"><table><tr><td class=\"PBeforeParameters\"><span class=\"SHKeyword\">private static</span> LightweightList&lt;<span class=\"SHKeyword\">int</span>&gt;[] CreateNodeDepthMatrix(</td><td class=\"PParametersParentCell\"><table class=\"PParameters\"><tr><td class=\"PType first\"><span class=\"SHKeyword\">int</span>&nbsp;</td><td class=\"PName last\">nodeCount,</td></tr><tr><td class=\"PType first\"><span class=\"SHKeyword\">int</span>&nbsp;</td><td class=\"PName last\">inputCount</td></tr></table></td><td class=\"PAfterParameters\">)</td></tr></table></div></div></div>"});